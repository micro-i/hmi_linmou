// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: algorithm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_algorithm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_algorithm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_algorithm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_algorithm_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_algorithm_2eproto;
namespace service_v2 {
class Feature;
struct FeatureDefaultTypeInternal;
extern FeatureDefaultTypeInternal _Feature_default_instance_;
class Features;
struct FeaturesDefaultTypeInternal;
extern FeaturesDefaultTypeInternal _Features_default_instance_;
class Features_FeatureEntry_DoNotUse;
struct Features_FeatureEntry_DoNotUseDefaultTypeInternal;
extern Features_FeatureEntry_DoNotUseDefaultTypeInternal _Features_FeatureEntry_DoNotUse_default_instance_;
class InferenceReply;
struct InferenceReplyDefaultTypeInternal;
extern InferenceReplyDefaultTypeInternal _InferenceReply_default_instance_;
class InferenceRequest;
struct InferenceRequestDefaultTypeInternal;
extern InferenceRequestDefaultTypeInternal _InferenceRequest_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class SingleInferenceReply;
struct SingleInferenceReplyDefaultTypeInternal;
extern SingleInferenceReplyDefaultTypeInternal _SingleInferenceReply_default_instance_;
}  // namespace service_v2
PROTOBUF_NAMESPACE_OPEN
template<> ::service_v2::Feature* Arena::CreateMaybeMessage<::service_v2::Feature>(Arena*);
template<> ::service_v2::Features* Arena::CreateMaybeMessage<::service_v2::Features>(Arena*);
template<> ::service_v2::Features_FeatureEntry_DoNotUse* Arena::CreateMaybeMessage<::service_v2::Features_FeatureEntry_DoNotUse>(Arena*);
template<> ::service_v2::InferenceReply* Arena::CreateMaybeMessage<::service_v2::InferenceReply>(Arena*);
template<> ::service_v2::InferenceRequest* Arena::CreateMaybeMessage<::service_v2::InferenceRequest>(Arena*);
template<> ::service_v2::Point* Arena::CreateMaybeMessage<::service_v2::Point>(Arena*);
template<> ::service_v2::SingleInferenceReply* Arena::CreateMaybeMessage<::service_v2::SingleInferenceReply>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service_v2 {

// ===================================================================

class Feature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_v2.Feature) */ {
 public:
  inline Feature() : Feature(nullptr) {}
  ~Feature() override;
  explicit PROTOBUF_CONSTEXPR Feature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Feature(const Feature& from);
  Feature(Feature&& from) noexcept
    : Feature() {
    *this = ::std::move(from);
  }

  inline Feature& operator=(const Feature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Feature& operator=(Feature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Feature& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kFeature = 1,
    kFeatureFloat = 2,
    kFeatureInt32 = 3,
    KIND_NOT_SET = 0,
  };

  static inline const Feature* internal_default_instance() {
    return reinterpret_cast<const Feature*>(
               &_Feature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Feature& a, Feature& b) {
    a.Swap(&b);
  }
  inline void Swap(Feature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Feature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Feature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Feature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Feature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Feature& from) {
    Feature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Feature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_v2.Feature";
  }
  protected:
  explicit Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureFieldNumber = 1,
    kFeatureFloatFieldNumber = 2,
    kFeatureInt32FieldNumber = 3,
  };
  // string feature = 1;
  bool has_feature() const;
  private:
  bool _internal_has_feature() const;
  public:
  void clear_feature();
  const std::string& feature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feature();
  PROTOBUF_NODISCARD std::string* release_feature();
  void set_allocated_feature(std::string* feature);
  private:
  const std::string& _internal_feature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feature(const std::string& value);
  std::string* _internal_mutable_feature();
  public:

  // float feature_float = 2;
  bool has_feature_float() const;
  private:
  bool _internal_has_feature_float() const;
  public:
  void clear_feature_float();
  float feature_float() const;
  void set_feature_float(float value);
  private:
  float _internal_feature_float() const;
  void _internal_set_feature_float(float value);
  public:

  // int32 feature_int32 = 3;
  bool has_feature_int32() const;
  private:
  bool _internal_has_feature_int32() const;
  public:
  void clear_feature_int32();
  int32_t feature_int32() const;
  void set_feature_int32(int32_t value);
  private:
  int32_t _internal_feature_int32() const;
  void _internal_set_feature_int32(int32_t value);
  public:

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:service_v2.Feature)
 private:
  class _Internal;
  void set_has_feature();
  void set_has_feature_float();
  void set_has_feature_int32();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feature_;
      float feature_float_;
      int32_t feature_int32_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_algorithm_2eproto;
};
// -------------------------------------------------------------------

class Features_FeatureEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Features_FeatureEntry_DoNotUse, 
    std::string, ::service_v2::Feature,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Features_FeatureEntry_DoNotUse, 
    std::string, ::service_v2::Feature,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Features_FeatureEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Features_FeatureEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Features_FeatureEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Features_FeatureEntry_DoNotUse& other);
  static const Features_FeatureEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Features_FeatureEntry_DoNotUse*>(&_Features_FeatureEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "service_v2.Features.FeatureEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_algorithm_2eproto;
};

// -------------------------------------------------------------------

class Features final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_v2.Features) */ {
 public:
  inline Features() : Features(nullptr) {}
  ~Features() override;
  explicit PROTOBUF_CONSTEXPR Features(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Features(const Features& from);
  Features(Features&& from) noexcept
    : Features() {
    *this = ::std::move(from);
  }

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }
  inline Features& operator=(Features&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Features& default_instance() {
    return *internal_default_instance();
  }
  static inline const Features* internal_default_instance() {
    return reinterpret_cast<const Features*>(
               &_Features_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Features& a, Features& b) {
    a.Swap(&b);
  }
  inline void Swap(Features* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Features* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Features* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Features>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Features& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Features& from) {
    Features::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Features* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_v2.Features";
  }
  protected:
  explicit Features(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFeatureFieldNumber = 1,
  };
  // map<string, .service_v2.Feature> feature = 1;
  int feature_size() const;
  private:
  int _internal_feature_size() const;
  public:
  void clear_feature();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::service_v2::Feature >&
      _internal_feature() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::service_v2::Feature >*
      _internal_mutable_feature();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::service_v2::Feature >&
      feature() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::service_v2::Feature >*
      mutable_feature();

  // @@protoc_insertion_point(class_scope:service_v2.Features)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Features_FeatureEntry_DoNotUse,
        std::string, ::service_v2::Feature,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> feature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_algorithm_2eproto;
};
// -------------------------------------------------------------------

class InferenceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_v2.InferenceRequest) */ {
 public:
  inline InferenceRequest() : InferenceRequest(nullptr) {}
  ~InferenceRequest() override;
  explicit PROTOBUF_CONSTEXPR InferenceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferenceRequest(const InferenceRequest& from);
  InferenceRequest(InferenceRequest&& from) noexcept
    : InferenceRequest() {
    *this = ::std::move(from);
  }

  inline InferenceRequest& operator=(const InferenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferenceRequest& operator=(InferenceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferenceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InferenceRequest* internal_default_instance() {
    return reinterpret_cast<const InferenceRequest*>(
               &_InferenceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InferenceRequest& a, InferenceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InferenceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferenceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferenceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferenceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferenceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferenceRequest& from) {
    InferenceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferenceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_v2.InferenceRequest";
  }
  protected:
  explicit InferenceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 12,
    kEncodedImageFieldNumber = 7,
    kDtypeFieldNumber = 8,
    kWidthIdFieldNumber = 1,
    kHeightIdFieldNumber = 2,
    kDepthIdFieldNumber = 3,
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
    kDepthFieldNumber = 6,
    kProductIdFieldNumber = 9,
    kWorkpieceIdFieldNumber = 10,
    kTaskIdFieldNumber = 11,
  };
  // repeated .service_v2.Features features = 12;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  ::service_v2::Features* mutable_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Features >*
      mutable_features();
  private:
  const ::service_v2::Features& _internal_features(int index) const;
  ::service_v2::Features* _internal_add_features();
  public:
  const ::service_v2::Features& features(int index) const;
  ::service_v2::Features* add_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Features >&
      features() const;

  // bytes encoded_image = 7;
  void clear_encoded_image();
  const std::string& encoded_image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded_image();
  PROTOBUF_NODISCARD std::string* release_encoded_image();
  void set_allocated_encoded_image(std::string* encoded_image);
  private:
  const std::string& _internal_encoded_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_image(const std::string& value);
  std::string* _internal_mutable_encoded_image();
  public:

  // string dtype = 8;
  void clear_dtype();
  const std::string& dtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* dtype);
  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(const std::string& value);
  std::string* _internal_mutable_dtype();
  public:

  // int32 width_id = 1;
  void clear_width_id();
  int32_t width_id() const;
  void set_width_id(int32_t value);
  private:
  int32_t _internal_width_id() const;
  void _internal_set_width_id(int32_t value);
  public:

  // int32 height_id = 2;
  void clear_height_id();
  int32_t height_id() const;
  void set_height_id(int32_t value);
  private:
  int32_t _internal_height_id() const;
  void _internal_set_height_id(int32_t value);
  public:

  // int32 depth_id = 3;
  void clear_depth_id();
  int32_t depth_id() const;
  void set_depth_id(int32_t value);
  private:
  int32_t _internal_depth_id() const;
  void _internal_set_depth_id(int32_t value);
  public:

  // int32 width = 4;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 5;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // int32 depth = 6;
  void clear_depth();
  int32_t depth() const;
  void set_depth(int32_t value);
  private:
  int32_t _internal_depth() const;
  void _internal_set_depth(int32_t value);
  public:

  // int32 product_id = 9;
  void clear_product_id();
  int32_t product_id() const;
  void set_product_id(int32_t value);
  private:
  int32_t _internal_product_id() const;
  void _internal_set_product_id(int32_t value);
  public:

  // int32 workpiece_id = 10;
  void clear_workpiece_id();
  int32_t workpiece_id() const;
  void set_workpiece_id(int32_t value);
  private:
  int32_t _internal_workpiece_id() const;
  void _internal_set_workpiece_id(int32_t value);
  public:

  // int32 task_id = 11;
  void clear_task_id();
  int32_t task_id() const;
  void set_task_id(int32_t value);
  private:
  int32_t _internal_task_id() const;
  void _internal_set_task_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_v2.InferenceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Features > features_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_image_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dtype_;
    int32_t width_id_;
    int32_t height_id_;
    int32_t depth_id_;
    int32_t width_;
    int32_t height_;
    int32_t depth_;
    int32_t product_id_;
    int32_t workpiece_id_;
    int32_t task_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_algorithm_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_v2.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_v2.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 z = 3;
  void clear_z();
  int32_t z() const;
  void set_z(int32_t value);
  private:
  int32_t _internal_z() const;
  void _internal_set_z(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_v2.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    int32_t z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_algorithm_2eproto;
};
// -------------------------------------------------------------------

class SingleInferenceReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_v2.SingleInferenceReply) */ {
 public:
  inline SingleInferenceReply() : SingleInferenceReply(nullptr) {}
  ~SingleInferenceReply() override;
  explicit PROTOBUF_CONSTEXPR SingleInferenceReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleInferenceReply(const SingleInferenceReply& from);
  SingleInferenceReply(SingleInferenceReply&& from) noexcept
    : SingleInferenceReply() {
    *this = ::std::move(from);
  }

  inline SingleInferenceReply& operator=(const SingleInferenceReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleInferenceReply& operator=(SingleInferenceReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleInferenceReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleInferenceReply* internal_default_instance() {
    return reinterpret_cast<const SingleInferenceReply*>(
               &_SingleInferenceReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SingleInferenceReply& a, SingleInferenceReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleInferenceReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleInferenceReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleInferenceReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleInferenceReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleInferenceReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleInferenceReply& from) {
    SingleInferenceReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleInferenceReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_v2.SingleInferenceReply";
  }
  protected:
  explicit SingleInferenceReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kClassNameFieldNumber = 2,
    kMaskFieldNumber = 10,
    kXminFieldNumber = 3,
    kYminFieldNumber = 4,
    kZminFieldNumber = 5,
    kXmaxFieldNumber = 6,
    kYmaxFieldNumber = 7,
    kZmaxFieldNumber = 8,
    kScoreFieldNumber = 9,
  };
  // repeated .service_v2.Point points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::service_v2::Point* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Point >*
      mutable_points();
  private:
  const ::service_v2::Point& _internal_points(int index) const;
  ::service_v2::Point* _internal_add_points();
  public:
  const ::service_v2::Point& points(int index) const;
  ::service_v2::Point* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Point >&
      points() const;

  // string class_name = 2;
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // bytes mask = 10;
  void clear_mask();
  const std::string& mask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mask();
  PROTOBUF_NODISCARD std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // float xmin = 3;
  void clear_xmin();
  float xmin() const;
  void set_xmin(float value);
  private:
  float _internal_xmin() const;
  void _internal_set_xmin(float value);
  public:

  // float ymin = 4;
  void clear_ymin();
  float ymin() const;
  void set_ymin(float value);
  private:
  float _internal_ymin() const;
  void _internal_set_ymin(float value);
  public:

  // float zmin = 5;
  void clear_zmin();
  float zmin() const;
  void set_zmin(float value);
  private:
  float _internal_zmin() const;
  void _internal_set_zmin(float value);
  public:

  // float xmax = 6;
  void clear_xmax();
  float xmax() const;
  void set_xmax(float value);
  private:
  float _internal_xmax() const;
  void _internal_set_xmax(float value);
  public:

  // float ymax = 7;
  void clear_ymax();
  float ymax() const;
  void set_ymax(float value);
  private:
  float _internal_ymax() const;
  void _internal_set_ymax(float value);
  public:

  // float zmax = 8;
  void clear_zmax();
  float zmax() const;
  void set_zmax(float value);
  private:
  float _internal_zmax() const;
  void _internal_set_zmax(float value);
  public:

  // float score = 9;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:service_v2.SingleInferenceReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Point > points_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
    float xmin_;
    float ymin_;
    float zmin_;
    float xmax_;
    float ymax_;
    float zmax_;
    float score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_algorithm_2eproto;
};
// -------------------------------------------------------------------

class InferenceReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_v2.InferenceReply) */ {
 public:
  inline InferenceReply() : InferenceReply(nullptr) {}
  ~InferenceReply() override;
  explicit PROTOBUF_CONSTEXPR InferenceReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferenceReply(const InferenceReply& from);
  InferenceReply(InferenceReply&& from) noexcept
    : InferenceReply() {
    *this = ::std::move(from);
  }

  inline InferenceReply& operator=(const InferenceReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferenceReply& operator=(InferenceReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferenceReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const InferenceReply* internal_default_instance() {
    return reinterpret_cast<const InferenceReply*>(
               &_InferenceReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InferenceReply& a, InferenceReply& b) {
    a.Swap(&b);
  }
  inline void Swap(InferenceReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferenceReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferenceReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferenceReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferenceReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferenceReply& from) {
    InferenceReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferenceReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_v2.InferenceReply";
  }
  protected:
  explicit InferenceReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSingleInferenceReplyFieldNumber = 8,
    kNumDetectionsFieldNumber = 1,
    kWidthIdFieldNumber = 2,
    kHeightIdFieldNumber = 3,
    kDepthIdFieldNumber = 4,
    kProductIdFieldNumber = 5,
    kWorkpieceIdFieldNumber = 6,
    kTaskIdFieldNumber = 7,
  };
  // repeated .service_v2.SingleInferenceReply singleInferenceReply = 8;
  int singleinferencereply_size() const;
  private:
  int _internal_singleinferencereply_size() const;
  public:
  void clear_singleinferencereply();
  ::service_v2::SingleInferenceReply* mutable_singleinferencereply(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::SingleInferenceReply >*
      mutable_singleinferencereply();
  private:
  const ::service_v2::SingleInferenceReply& _internal_singleinferencereply(int index) const;
  ::service_v2::SingleInferenceReply* _internal_add_singleinferencereply();
  public:
  const ::service_v2::SingleInferenceReply& singleinferencereply(int index) const;
  ::service_v2::SingleInferenceReply* add_singleinferencereply();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::SingleInferenceReply >&
      singleinferencereply() const;

  // int32 num_detections = 1;
  void clear_num_detections();
  int32_t num_detections() const;
  void set_num_detections(int32_t value);
  private:
  int32_t _internal_num_detections() const;
  void _internal_set_num_detections(int32_t value);
  public:

  // int32 width_id = 2;
  void clear_width_id();
  int32_t width_id() const;
  void set_width_id(int32_t value);
  private:
  int32_t _internal_width_id() const;
  void _internal_set_width_id(int32_t value);
  public:

  // int32 height_id = 3;
  void clear_height_id();
  int32_t height_id() const;
  void set_height_id(int32_t value);
  private:
  int32_t _internal_height_id() const;
  void _internal_set_height_id(int32_t value);
  public:

  // int32 depth_id = 4;
  void clear_depth_id();
  int32_t depth_id() const;
  void set_depth_id(int32_t value);
  private:
  int32_t _internal_depth_id() const;
  void _internal_set_depth_id(int32_t value);
  public:

  // int32 product_id = 5;
  void clear_product_id();
  int32_t product_id() const;
  void set_product_id(int32_t value);
  private:
  int32_t _internal_product_id() const;
  void _internal_set_product_id(int32_t value);
  public:

  // int32 workpiece_id = 6;
  void clear_workpiece_id();
  int32_t workpiece_id() const;
  void set_workpiece_id(int32_t value);
  private:
  int32_t _internal_workpiece_id() const;
  void _internal_set_workpiece_id(int32_t value);
  public:

  // int32 task_id = 7;
  void clear_task_id();
  int32_t task_id() const;
  void set_task_id(int32_t value);
  private:
  int32_t _internal_task_id() const;
  void _internal_set_task_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_v2.InferenceReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::SingleInferenceReply > singleinferencereply_;
    int32_t num_detections_;
    int32_t width_id_;
    int32_t height_id_;
    int32_t depth_id_;
    int32_t product_id_;
    int32_t workpiece_id_;
    int32_t task_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_algorithm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Feature

// string feature = 1;
inline bool Feature::_internal_has_feature() const {
  return kind_case() == kFeature;
}
inline bool Feature::has_feature() const {
  return _internal_has_feature();
}
inline void Feature::set_has_feature() {
  _impl_._oneof_case_[0] = kFeature;
}
inline void Feature::clear_feature() {
  if (_internal_has_feature()) {
    _impl_.kind_.feature_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& Feature::feature() const {
  // @@protoc_insertion_point(field_get:service_v2.Feature.feature)
  return _internal_feature();
}
template <typename ArgT0, typename... ArgT>
inline void Feature::set_feature(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_feature()) {
    clear_kind();
    set_has_feature();
    _impl_.kind_.feature_.InitDefault();
  }
  _impl_.kind_.feature_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_v2.Feature.feature)
}
inline std::string* Feature::mutable_feature() {
  std::string* _s = _internal_mutable_feature();
  // @@protoc_insertion_point(field_mutable:service_v2.Feature.feature)
  return _s;
}
inline const std::string& Feature::_internal_feature() const {
  if (_internal_has_feature()) {
    return _impl_.kind_.feature_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Feature::_internal_set_feature(const std::string& value) {
  if (!_internal_has_feature()) {
    clear_kind();
    set_has_feature();
    _impl_.kind_.feature_.InitDefault();
  }
  _impl_.kind_.feature_.Set(value, GetArenaForAllocation());
}
inline std::string* Feature::_internal_mutable_feature() {
  if (!_internal_has_feature()) {
    clear_kind();
    set_has_feature();
    _impl_.kind_.feature_.InitDefault();
  }
  return _impl_.kind_.feature_.Mutable(      GetArenaForAllocation());
}
inline std::string* Feature::release_feature() {
  // @@protoc_insertion_point(field_release:service_v2.Feature.feature)
  if (_internal_has_feature()) {
    clear_has_kind();
    return _impl_.kind_.feature_.Release();
  } else {
    return nullptr;
  }
}
inline void Feature::set_allocated_feature(std::string* feature) {
  if (has_kind()) {
    clear_kind();
  }
  if (feature != nullptr) {
    set_has_feature();
    _impl_.kind_.feature_.InitAllocated(feature, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service_v2.Feature.feature)
}

// float feature_float = 2;
inline bool Feature::_internal_has_feature_float() const {
  return kind_case() == kFeatureFloat;
}
inline bool Feature::has_feature_float() const {
  return _internal_has_feature_float();
}
inline void Feature::set_has_feature_float() {
  _impl_._oneof_case_[0] = kFeatureFloat;
}
inline void Feature::clear_feature_float() {
  if (_internal_has_feature_float()) {
    _impl_.kind_.feature_float_ = 0;
    clear_has_kind();
  }
}
inline float Feature::_internal_feature_float() const {
  if (_internal_has_feature_float()) {
    return _impl_.kind_.feature_float_;
  }
  return 0;
}
inline void Feature::_internal_set_feature_float(float value) {
  if (!_internal_has_feature_float()) {
    clear_kind();
    set_has_feature_float();
  }
  _impl_.kind_.feature_float_ = value;
}
inline float Feature::feature_float() const {
  // @@protoc_insertion_point(field_get:service_v2.Feature.feature_float)
  return _internal_feature_float();
}
inline void Feature::set_feature_float(float value) {
  _internal_set_feature_float(value);
  // @@protoc_insertion_point(field_set:service_v2.Feature.feature_float)
}

// int32 feature_int32 = 3;
inline bool Feature::_internal_has_feature_int32() const {
  return kind_case() == kFeatureInt32;
}
inline bool Feature::has_feature_int32() const {
  return _internal_has_feature_int32();
}
inline void Feature::set_has_feature_int32() {
  _impl_._oneof_case_[0] = kFeatureInt32;
}
inline void Feature::clear_feature_int32() {
  if (_internal_has_feature_int32()) {
    _impl_.kind_.feature_int32_ = 0;
    clear_has_kind();
  }
}
inline int32_t Feature::_internal_feature_int32() const {
  if (_internal_has_feature_int32()) {
    return _impl_.kind_.feature_int32_;
  }
  return 0;
}
inline void Feature::_internal_set_feature_int32(int32_t value) {
  if (!_internal_has_feature_int32()) {
    clear_kind();
    set_has_feature_int32();
  }
  _impl_.kind_.feature_int32_ = value;
}
inline int32_t Feature::feature_int32() const {
  // @@protoc_insertion_point(field_get:service_v2.Feature.feature_int32)
  return _internal_feature_int32();
}
inline void Feature::set_feature_int32(int32_t value) {
  _internal_set_feature_int32(value);
  // @@protoc_insertion_point(field_set:service_v2.Feature.feature_int32)
}

inline bool Feature::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Feature::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Feature::KindCase Feature::kind_case() const {
  return Feature::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Features

// map<string, .service_v2.Feature> feature = 1;
inline int Features::_internal_feature_size() const {
  return _impl_.feature_.size();
}
inline int Features::feature_size() const {
  return _internal_feature_size();
}
inline void Features::clear_feature() {
  _impl_.feature_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::service_v2::Feature >&
Features::_internal_feature() const {
  return _impl_.feature_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::service_v2::Feature >&
Features::feature() const {
  // @@protoc_insertion_point(field_map:service_v2.Features.feature)
  return _internal_feature();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::service_v2::Feature >*
Features::_internal_mutable_feature() {
  return _impl_.feature_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::service_v2::Feature >*
Features::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_map:service_v2.Features.feature)
  return _internal_mutable_feature();
}

// -------------------------------------------------------------------

// InferenceRequest

// int32 width_id = 1;
inline void InferenceRequest::clear_width_id() {
  _impl_.width_id_ = 0;
}
inline int32_t InferenceRequest::_internal_width_id() const {
  return _impl_.width_id_;
}
inline int32_t InferenceRequest::width_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.width_id)
  return _internal_width_id();
}
inline void InferenceRequest::_internal_set_width_id(int32_t value) {
  
  _impl_.width_id_ = value;
}
inline void InferenceRequest::set_width_id(int32_t value) {
  _internal_set_width_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.width_id)
}

// int32 height_id = 2;
inline void InferenceRequest::clear_height_id() {
  _impl_.height_id_ = 0;
}
inline int32_t InferenceRequest::_internal_height_id() const {
  return _impl_.height_id_;
}
inline int32_t InferenceRequest::height_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.height_id)
  return _internal_height_id();
}
inline void InferenceRequest::_internal_set_height_id(int32_t value) {
  
  _impl_.height_id_ = value;
}
inline void InferenceRequest::set_height_id(int32_t value) {
  _internal_set_height_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.height_id)
}

// int32 depth_id = 3;
inline void InferenceRequest::clear_depth_id() {
  _impl_.depth_id_ = 0;
}
inline int32_t InferenceRequest::_internal_depth_id() const {
  return _impl_.depth_id_;
}
inline int32_t InferenceRequest::depth_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.depth_id)
  return _internal_depth_id();
}
inline void InferenceRequest::_internal_set_depth_id(int32_t value) {
  
  _impl_.depth_id_ = value;
}
inline void InferenceRequest::set_depth_id(int32_t value) {
  _internal_set_depth_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.depth_id)
}

// int32 width = 4;
inline void InferenceRequest::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t InferenceRequest::_internal_width() const {
  return _impl_.width_;
}
inline int32_t InferenceRequest::width() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.width)
  return _internal_width();
}
inline void InferenceRequest::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void InferenceRequest::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.width)
}

// int32 height = 5;
inline void InferenceRequest::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t InferenceRequest::_internal_height() const {
  return _impl_.height_;
}
inline int32_t InferenceRequest::height() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.height)
  return _internal_height();
}
inline void InferenceRequest::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void InferenceRequest::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.height)
}

// int32 depth = 6;
inline void InferenceRequest::clear_depth() {
  _impl_.depth_ = 0;
}
inline int32_t InferenceRequest::_internal_depth() const {
  return _impl_.depth_;
}
inline int32_t InferenceRequest::depth() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.depth)
  return _internal_depth();
}
inline void InferenceRequest::_internal_set_depth(int32_t value) {
  
  _impl_.depth_ = value;
}
inline void InferenceRequest::set_depth(int32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.depth)
}

// bytes encoded_image = 7;
inline void InferenceRequest::clear_encoded_image() {
  _impl_.encoded_image_.ClearToEmpty();
}
inline const std::string& InferenceRequest::encoded_image() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.encoded_image)
  return _internal_encoded_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InferenceRequest::set_encoded_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encoded_image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.encoded_image)
}
inline std::string* InferenceRequest::mutable_encoded_image() {
  std::string* _s = _internal_mutable_encoded_image();
  // @@protoc_insertion_point(field_mutable:service_v2.InferenceRequest.encoded_image)
  return _s;
}
inline const std::string& InferenceRequest::_internal_encoded_image() const {
  return _impl_.encoded_image_.Get();
}
inline void InferenceRequest::_internal_set_encoded_image(const std::string& value) {
  
  _impl_.encoded_image_.Set(value, GetArenaForAllocation());
}
inline std::string* InferenceRequest::_internal_mutable_encoded_image() {
  
  return _impl_.encoded_image_.Mutable(GetArenaForAllocation());
}
inline std::string* InferenceRequest::release_encoded_image() {
  // @@protoc_insertion_point(field_release:service_v2.InferenceRequest.encoded_image)
  return _impl_.encoded_image_.Release();
}
inline void InferenceRequest::set_allocated_encoded_image(std::string* encoded_image) {
  if (encoded_image != nullptr) {
    
  } else {
    
  }
  _impl_.encoded_image_.SetAllocated(encoded_image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encoded_image_.IsDefault()) {
    _impl_.encoded_image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_v2.InferenceRequest.encoded_image)
}

// string dtype = 8;
inline void InferenceRequest::clear_dtype() {
  _impl_.dtype_.ClearToEmpty();
}
inline const std::string& InferenceRequest::dtype() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.dtype)
  return _internal_dtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InferenceRequest::set_dtype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.dtype)
}
inline std::string* InferenceRequest::mutable_dtype() {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:service_v2.InferenceRequest.dtype)
  return _s;
}
inline const std::string& InferenceRequest::_internal_dtype() const {
  return _impl_.dtype_.Get();
}
inline void InferenceRequest::_internal_set_dtype(const std::string& value) {
  
  _impl_.dtype_.Set(value, GetArenaForAllocation());
}
inline std::string* InferenceRequest::_internal_mutable_dtype() {
  
  return _impl_.dtype_.Mutable(GetArenaForAllocation());
}
inline std::string* InferenceRequest::release_dtype() {
  // @@protoc_insertion_point(field_release:service_v2.InferenceRequest.dtype)
  return _impl_.dtype_.Release();
}
inline void InferenceRequest::set_allocated_dtype(std::string* dtype) {
  if (dtype != nullptr) {
    
  } else {
    
  }
  _impl_.dtype_.SetAllocated(dtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dtype_.IsDefault()) {
    _impl_.dtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_v2.InferenceRequest.dtype)
}

// int32 product_id = 9;
inline void InferenceRequest::clear_product_id() {
  _impl_.product_id_ = 0;
}
inline int32_t InferenceRequest::_internal_product_id() const {
  return _impl_.product_id_;
}
inline int32_t InferenceRequest::product_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.product_id)
  return _internal_product_id();
}
inline void InferenceRequest::_internal_set_product_id(int32_t value) {
  
  _impl_.product_id_ = value;
}
inline void InferenceRequest::set_product_id(int32_t value) {
  _internal_set_product_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.product_id)
}

// int32 workpiece_id = 10;
inline void InferenceRequest::clear_workpiece_id() {
  _impl_.workpiece_id_ = 0;
}
inline int32_t InferenceRequest::_internal_workpiece_id() const {
  return _impl_.workpiece_id_;
}
inline int32_t InferenceRequest::workpiece_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.workpiece_id)
  return _internal_workpiece_id();
}
inline void InferenceRequest::_internal_set_workpiece_id(int32_t value) {
  
  _impl_.workpiece_id_ = value;
}
inline void InferenceRequest::set_workpiece_id(int32_t value) {
  _internal_set_workpiece_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.workpiece_id)
}

// int32 task_id = 11;
inline void InferenceRequest::clear_task_id() {
  _impl_.task_id_ = 0;
}
inline int32_t InferenceRequest::_internal_task_id() const {
  return _impl_.task_id_;
}
inline int32_t InferenceRequest::task_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.task_id)
  return _internal_task_id();
}
inline void InferenceRequest::_internal_set_task_id(int32_t value) {
  
  _impl_.task_id_ = value;
}
inline void InferenceRequest::set_task_id(int32_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceRequest.task_id)
}

// repeated .service_v2.Features features = 12;
inline int InferenceRequest::_internal_features_size() const {
  return _impl_.features_.size();
}
inline int InferenceRequest::features_size() const {
  return _internal_features_size();
}
inline void InferenceRequest::clear_features() {
  _impl_.features_.Clear();
}
inline ::service_v2::Features* InferenceRequest::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:service_v2.InferenceRequest.features)
  return _impl_.features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Features >*
InferenceRequest::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:service_v2.InferenceRequest.features)
  return &_impl_.features_;
}
inline const ::service_v2::Features& InferenceRequest::_internal_features(int index) const {
  return _impl_.features_.Get(index);
}
inline const ::service_v2::Features& InferenceRequest::features(int index) const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceRequest.features)
  return _internal_features(index);
}
inline ::service_v2::Features* InferenceRequest::_internal_add_features() {
  return _impl_.features_.Add();
}
inline ::service_v2::Features* InferenceRequest::add_features() {
  ::service_v2::Features* _add = _internal_add_features();
  // @@protoc_insertion_point(field_add:service_v2.InferenceRequest.features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Features >&
InferenceRequest::features() const {
  // @@protoc_insertion_point(field_list:service_v2.InferenceRequest.features)
  return _impl_.features_;
}

// -------------------------------------------------------------------

// Point

// int32 x = 1;
inline void Point::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t Point::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Point::x() const {
  // @@protoc_insertion_point(field_get:service_v2.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void Point::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:service_v2.Point.x)
}

// int32 y = 2;
inline void Point::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t Point::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Point::y() const {
  // @@protoc_insertion_point(field_get:service_v2.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void Point::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:service_v2.Point.y)
}

// int32 z = 3;
inline void Point::clear_z() {
  _impl_.z_ = 0;
}
inline int32_t Point::_internal_z() const {
  return _impl_.z_;
}
inline int32_t Point::z() const {
  // @@protoc_insertion_point(field_get:service_v2.Point.z)
  return _internal_z();
}
inline void Point::_internal_set_z(int32_t value) {
  
  _impl_.z_ = value;
}
inline void Point::set_z(int32_t value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:service_v2.Point.z)
}

// -------------------------------------------------------------------

// SingleInferenceReply

// repeated .service_v2.Point points = 1;
inline int SingleInferenceReply::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int SingleInferenceReply::points_size() const {
  return _internal_points_size();
}
inline void SingleInferenceReply::clear_points() {
  _impl_.points_.Clear();
}
inline ::service_v2::Point* SingleInferenceReply::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:service_v2.SingleInferenceReply.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Point >*
SingleInferenceReply::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:service_v2.SingleInferenceReply.points)
  return &_impl_.points_;
}
inline const ::service_v2::Point& SingleInferenceReply::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::service_v2::Point& SingleInferenceReply::points(int index) const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.points)
  return _internal_points(index);
}
inline ::service_v2::Point* SingleInferenceReply::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::service_v2::Point* SingleInferenceReply::add_points() {
  ::service_v2::Point* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:service_v2.SingleInferenceReply.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::Point >&
SingleInferenceReply::points() const {
  // @@protoc_insertion_point(field_list:service_v2.SingleInferenceReply.points)
  return _impl_.points_;
}

// string class_name = 2;
inline void SingleInferenceReply::clear_class_name() {
  _impl_.class_name_.ClearToEmpty();
}
inline const std::string& SingleInferenceReply::class_name() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleInferenceReply::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.class_name)
}
inline std::string* SingleInferenceReply::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:service_v2.SingleInferenceReply.class_name)
  return _s;
}
inline const std::string& SingleInferenceReply::_internal_class_name() const {
  return _impl_.class_name_.Get();
}
inline void SingleInferenceReply::_internal_set_class_name(const std::string& value) {
  
  _impl_.class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleInferenceReply::_internal_mutable_class_name() {
  
  return _impl_.class_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SingleInferenceReply::release_class_name() {
  // @@protoc_insertion_point(field_release:service_v2.SingleInferenceReply.class_name)
  return _impl_.class_name_.Release();
}
inline void SingleInferenceReply::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  _impl_.class_name_.SetAllocated(class_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class_name_.IsDefault()) {
    _impl_.class_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_v2.SingleInferenceReply.class_name)
}

// float xmin = 3;
inline void SingleInferenceReply::clear_xmin() {
  _impl_.xmin_ = 0;
}
inline float SingleInferenceReply::_internal_xmin() const {
  return _impl_.xmin_;
}
inline float SingleInferenceReply::xmin() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.xmin)
  return _internal_xmin();
}
inline void SingleInferenceReply::_internal_set_xmin(float value) {
  
  _impl_.xmin_ = value;
}
inline void SingleInferenceReply::set_xmin(float value) {
  _internal_set_xmin(value);
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.xmin)
}

// float ymin = 4;
inline void SingleInferenceReply::clear_ymin() {
  _impl_.ymin_ = 0;
}
inline float SingleInferenceReply::_internal_ymin() const {
  return _impl_.ymin_;
}
inline float SingleInferenceReply::ymin() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.ymin)
  return _internal_ymin();
}
inline void SingleInferenceReply::_internal_set_ymin(float value) {
  
  _impl_.ymin_ = value;
}
inline void SingleInferenceReply::set_ymin(float value) {
  _internal_set_ymin(value);
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.ymin)
}

// float zmin = 5;
inline void SingleInferenceReply::clear_zmin() {
  _impl_.zmin_ = 0;
}
inline float SingleInferenceReply::_internal_zmin() const {
  return _impl_.zmin_;
}
inline float SingleInferenceReply::zmin() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.zmin)
  return _internal_zmin();
}
inline void SingleInferenceReply::_internal_set_zmin(float value) {
  
  _impl_.zmin_ = value;
}
inline void SingleInferenceReply::set_zmin(float value) {
  _internal_set_zmin(value);
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.zmin)
}

// float xmax = 6;
inline void SingleInferenceReply::clear_xmax() {
  _impl_.xmax_ = 0;
}
inline float SingleInferenceReply::_internal_xmax() const {
  return _impl_.xmax_;
}
inline float SingleInferenceReply::xmax() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.xmax)
  return _internal_xmax();
}
inline void SingleInferenceReply::_internal_set_xmax(float value) {
  
  _impl_.xmax_ = value;
}
inline void SingleInferenceReply::set_xmax(float value) {
  _internal_set_xmax(value);
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.xmax)
}

// float ymax = 7;
inline void SingleInferenceReply::clear_ymax() {
  _impl_.ymax_ = 0;
}
inline float SingleInferenceReply::_internal_ymax() const {
  return _impl_.ymax_;
}
inline float SingleInferenceReply::ymax() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.ymax)
  return _internal_ymax();
}
inline void SingleInferenceReply::_internal_set_ymax(float value) {
  
  _impl_.ymax_ = value;
}
inline void SingleInferenceReply::set_ymax(float value) {
  _internal_set_ymax(value);
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.ymax)
}

// float zmax = 8;
inline void SingleInferenceReply::clear_zmax() {
  _impl_.zmax_ = 0;
}
inline float SingleInferenceReply::_internal_zmax() const {
  return _impl_.zmax_;
}
inline float SingleInferenceReply::zmax() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.zmax)
  return _internal_zmax();
}
inline void SingleInferenceReply::_internal_set_zmax(float value) {
  
  _impl_.zmax_ = value;
}
inline void SingleInferenceReply::set_zmax(float value) {
  _internal_set_zmax(value);
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.zmax)
}

// float score = 9;
inline void SingleInferenceReply::clear_score() {
  _impl_.score_ = 0;
}
inline float SingleInferenceReply::_internal_score() const {
  return _impl_.score_;
}
inline float SingleInferenceReply::score() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.score)
  return _internal_score();
}
inline void SingleInferenceReply::_internal_set_score(float value) {
  
  _impl_.score_ = value;
}
inline void SingleInferenceReply::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.score)
}

// bytes mask = 10;
inline void SingleInferenceReply::clear_mask() {
  _impl_.mask_.ClearToEmpty();
}
inline const std::string& SingleInferenceReply::mask() const {
  // @@protoc_insertion_point(field_get:service_v2.SingleInferenceReply.mask)
  return _internal_mask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleInferenceReply::set_mask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mask_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_v2.SingleInferenceReply.mask)
}
inline std::string* SingleInferenceReply::mutable_mask() {
  std::string* _s = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:service_v2.SingleInferenceReply.mask)
  return _s;
}
inline const std::string& SingleInferenceReply::_internal_mask() const {
  return _impl_.mask_.Get();
}
inline void SingleInferenceReply::_internal_set_mask(const std::string& value) {
  
  _impl_.mask_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleInferenceReply::_internal_mutable_mask() {
  
  return _impl_.mask_.Mutable(GetArenaForAllocation());
}
inline std::string* SingleInferenceReply::release_mask() {
  // @@protoc_insertion_point(field_release:service_v2.SingleInferenceReply.mask)
  return _impl_.mask_.Release();
}
inline void SingleInferenceReply::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    
  } else {
    
  }
  _impl_.mask_.SetAllocated(mask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_v2.SingleInferenceReply.mask)
}

// -------------------------------------------------------------------

// InferenceReply

// int32 num_detections = 1;
inline void InferenceReply::clear_num_detections() {
  _impl_.num_detections_ = 0;
}
inline int32_t InferenceReply::_internal_num_detections() const {
  return _impl_.num_detections_;
}
inline int32_t InferenceReply::num_detections() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceReply.num_detections)
  return _internal_num_detections();
}
inline void InferenceReply::_internal_set_num_detections(int32_t value) {
  
  _impl_.num_detections_ = value;
}
inline void InferenceReply::set_num_detections(int32_t value) {
  _internal_set_num_detections(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceReply.num_detections)
}

// int32 width_id = 2;
inline void InferenceReply::clear_width_id() {
  _impl_.width_id_ = 0;
}
inline int32_t InferenceReply::_internal_width_id() const {
  return _impl_.width_id_;
}
inline int32_t InferenceReply::width_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceReply.width_id)
  return _internal_width_id();
}
inline void InferenceReply::_internal_set_width_id(int32_t value) {
  
  _impl_.width_id_ = value;
}
inline void InferenceReply::set_width_id(int32_t value) {
  _internal_set_width_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceReply.width_id)
}

// int32 height_id = 3;
inline void InferenceReply::clear_height_id() {
  _impl_.height_id_ = 0;
}
inline int32_t InferenceReply::_internal_height_id() const {
  return _impl_.height_id_;
}
inline int32_t InferenceReply::height_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceReply.height_id)
  return _internal_height_id();
}
inline void InferenceReply::_internal_set_height_id(int32_t value) {
  
  _impl_.height_id_ = value;
}
inline void InferenceReply::set_height_id(int32_t value) {
  _internal_set_height_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceReply.height_id)
}

// int32 depth_id = 4;
inline void InferenceReply::clear_depth_id() {
  _impl_.depth_id_ = 0;
}
inline int32_t InferenceReply::_internal_depth_id() const {
  return _impl_.depth_id_;
}
inline int32_t InferenceReply::depth_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceReply.depth_id)
  return _internal_depth_id();
}
inline void InferenceReply::_internal_set_depth_id(int32_t value) {
  
  _impl_.depth_id_ = value;
}
inline void InferenceReply::set_depth_id(int32_t value) {
  _internal_set_depth_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceReply.depth_id)
}

// int32 product_id = 5;
inline void InferenceReply::clear_product_id() {
  _impl_.product_id_ = 0;
}
inline int32_t InferenceReply::_internal_product_id() const {
  return _impl_.product_id_;
}
inline int32_t InferenceReply::product_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceReply.product_id)
  return _internal_product_id();
}
inline void InferenceReply::_internal_set_product_id(int32_t value) {
  
  _impl_.product_id_ = value;
}
inline void InferenceReply::set_product_id(int32_t value) {
  _internal_set_product_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceReply.product_id)
}

// int32 workpiece_id = 6;
inline void InferenceReply::clear_workpiece_id() {
  _impl_.workpiece_id_ = 0;
}
inline int32_t InferenceReply::_internal_workpiece_id() const {
  return _impl_.workpiece_id_;
}
inline int32_t InferenceReply::workpiece_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceReply.workpiece_id)
  return _internal_workpiece_id();
}
inline void InferenceReply::_internal_set_workpiece_id(int32_t value) {
  
  _impl_.workpiece_id_ = value;
}
inline void InferenceReply::set_workpiece_id(int32_t value) {
  _internal_set_workpiece_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceReply.workpiece_id)
}

// int32 task_id = 7;
inline void InferenceReply::clear_task_id() {
  _impl_.task_id_ = 0;
}
inline int32_t InferenceReply::_internal_task_id() const {
  return _impl_.task_id_;
}
inline int32_t InferenceReply::task_id() const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceReply.task_id)
  return _internal_task_id();
}
inline void InferenceReply::_internal_set_task_id(int32_t value) {
  
  _impl_.task_id_ = value;
}
inline void InferenceReply::set_task_id(int32_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:service_v2.InferenceReply.task_id)
}

// repeated .service_v2.SingleInferenceReply singleInferenceReply = 8;
inline int InferenceReply::_internal_singleinferencereply_size() const {
  return _impl_.singleinferencereply_.size();
}
inline int InferenceReply::singleinferencereply_size() const {
  return _internal_singleinferencereply_size();
}
inline void InferenceReply::clear_singleinferencereply() {
  _impl_.singleinferencereply_.Clear();
}
inline ::service_v2::SingleInferenceReply* InferenceReply::mutable_singleinferencereply(int index) {
  // @@protoc_insertion_point(field_mutable:service_v2.InferenceReply.singleInferenceReply)
  return _impl_.singleinferencereply_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::SingleInferenceReply >*
InferenceReply::mutable_singleinferencereply() {
  // @@protoc_insertion_point(field_mutable_list:service_v2.InferenceReply.singleInferenceReply)
  return &_impl_.singleinferencereply_;
}
inline const ::service_v2::SingleInferenceReply& InferenceReply::_internal_singleinferencereply(int index) const {
  return _impl_.singleinferencereply_.Get(index);
}
inline const ::service_v2::SingleInferenceReply& InferenceReply::singleinferencereply(int index) const {
  // @@protoc_insertion_point(field_get:service_v2.InferenceReply.singleInferenceReply)
  return _internal_singleinferencereply(index);
}
inline ::service_v2::SingleInferenceReply* InferenceReply::_internal_add_singleinferencereply() {
  return _impl_.singleinferencereply_.Add();
}
inline ::service_v2::SingleInferenceReply* InferenceReply::add_singleinferencereply() {
  ::service_v2::SingleInferenceReply* _add = _internal_add_singleinferencereply();
  // @@protoc_insertion_point(field_add:service_v2.InferenceReply.singleInferenceReply)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_v2::SingleInferenceReply >&
InferenceReply::singleinferencereply() const {
  // @@protoc_insertion_point(field_list:service_v2.InferenceReply.singleInferenceReply)
  return _impl_.singleinferencereply_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_v2

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_algorithm_2eproto
